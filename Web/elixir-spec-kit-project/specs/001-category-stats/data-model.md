# 데이터 모델: 카테고리별 포스트 통계 페이지

**기능**: 카테고리 통계 페이지
**날짜**: 2025-12-30
**단계**: 1 - 설계 및 계약

## 엔티티 정의

### 기존 엔티티 (변경 불필요)

#### 태그 (기존 스키마)

**목적**: 포스트를 분류하는 데 사용되는 블로그 카테고리/태그를 나타냄

**스키마**: `lib/elixir_blog/blog/tag.ex`

**속성**:

- `id` (정수, 기본 키) - 고유 식별자
- `name` (문자열, 필수) - 표시 이름 (한국어/영어 지원)
- `slug` (문자열, 필수, 고유) - URL 친화적 식별자
- `inserted_at` (타임스탬프) - 레코드 생성 시간
- `updated_at` (타임스탬프) - 마지막 수정 시간

**관계**:

- `posts` - `posts_tags` 조인 테이블을 통한 포스트와의 다대다 관계

**검증 규칙**:

- `name`은 필수이며 고유해야 함
- `slug`는 필수이며 고유하고 URL 안전해야 함

**기능에서의 사용**:

- 카테고리 통계의 소스 엔티티
- CategoryGrid 컴포넌트에 표시됨
- 카테고리 상세 페이지 라우팅에 사용됨

---

#### 포스트 (기존 스키마)

**목적**: 콘텐츠와 메타데이터를 가진 블로그 포스트를 나타냄

**스키마**: `lib/elixir_blog/blog/post.ex`

**속성**:

- `id` (정수, 기본 키) - 고유 식별자
- `slug` (문자열, 필수, 고유) - URL 친화적 식별자
- `title` (문자열, 필수) - 포스트 제목
- `author` (문자열, 필수) - 포스트 작성자 이름
- `summary` (문자열) - 간단한 설명
- `thumbnail` (문자열) - 썸네일 이미지 경로
- `content_path` (문자열, 필수) - 마크다운 파일 경로
- `published_at` (타임스탬프, 필수) - 발행 날짜
- `is_popular` (불린, 기본값: false) - 인기 포스트 플래그
- `reading_time` (정수) - 예상 읽기 시간(분)
- `inserted_at` (타임스탬프) - 레코드 생성 시간
- `updated_at` (타임스탬프) - 마지막 수정 시간

**관계**:

- `tags` - `posts_tags` 조인 테이블을 통한 태그와의 다대다 관계

**인덱스**:

- `published_at` (정렬용)
- `is_popular` (필터링용)
- `slug` (조회용)

**기능에서의 사용**:

- 태그별 통계를 위해 카운트됨
- 인기 섹션을 위해 `is_popular`로 필터링됨
- 인기 포스트 섹션의 PostGrid에 표시됨

---

### 가상 엔티티 (런타임에 계산됨)

#### 카테고리통계 (가상)

**목적**: 카테고리별 포스트 수를 나타내는 집계 데이터 구조

**구조** (맵):

```elixir
%{
  id: integer,          # 태그 ID
  name: string,         # 태그 이름 (한국어/영어)
  slug: string,         # 라우팅용 태그 슬러그
  post_count: integer   # 이 태그를 가진 포스트 수
}
```

**소스**: `Blog.list_tags_with_post_counts/1` 쿼리로 계산됨

**속성**:

- `id` (정수) - 태그 고유 식별자
- `name` (문자열) - 태그 표시 이름
- `slug` (문자열) - 네비게이션용 URL 친화적 식별자
- `post_count` (정수) - 연관된 포스트의 집계 수 (없으면 0)

**검증 규칙**: 해당 없음 (읽기 전용 계산 데이터)

**기능에서의 사용**:

- CategoryGrid 컴포넌트의 주요 데이터 구조
- 카테고리 통계 개요 페이지에 표시됨
- 알파벳순(기본값) 또는 post_count순으로 정렬됨

**쿼리 소스**:

```elixir
# 의사 쿼리 (실제 구현은 contracts/blog_context.md에 있음)
SELECT t.id, t.name, t.slug, COUNT(pt.post_id) AS post_count
FROM tags t
LEFT JOIN posts_tags pt ON t.id = pt.tag_id
GROUP BY t.id
ORDER BY t.name ASC  -- 또는 post_count DESC
```

---

## 엔티티 관계

### 기존 데이터베이스 스키마

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   posts     │         │ posts_tags   │         │    tags     │
├─────────────┤         ├──────────────┤         ├─────────────┤
│ id (PK)     │────────>│ post_id (FK) │<────────│ id (PK)     │
│ slug        │         │ tag_id (FK)  │         │ name        │
│ title       │         └──────────────┘         │ slug        │
│ author      │                                  └─────────────┘
│ summary     │              (다대다)
│ is_popular  │
│ published_at│
│ ...         │
└─────────────┘
```

**조인 테이블**: `posts_tags`

- 복합 기본 키: `(post_id, tag_id)`
- 캐스케이드 삭제가 있는 외래 키 (포스트/태그 삭제 시 연관 제거)

### 카테고리 통계를 위한 데이터 플로우

```
데이터베이스 (posts_tags)
        ↓
  Ecto 집계 쿼리
  (GROUP BY tag_id, COUNT)
        ↓
  CategoryStatistic (가상)
  %{id, name, slug, post_count}
        ↓
  CategoryStatsLive Assigns
  (@categories, @popular_posts)
        ↓
  CategoryGrid 컴포넌트
  (통계 카드 렌더링)
```

---

## 상태 전환

### CategoryStatistic 생명주기

**생성**:

1. 사용자가 `/categories` 라우트로 이동
2. CategoryStatsLive 마운트
3. `Blog.list_tags_with_post_counts/1`이 집계 쿼리 실행
4. 결과가 맵 목록(CategoryStatistic 구조체)으로 구체화됨
5. LiveView 소켓에 할당됨 (`@categories`)

**업데이트**:

- **실시간**: 불필요 (통계는 특정 시점 스냅샷)
- **새로고침**: 페이지 새로고침 시 데이터베이스 재쿼리
- **캐시**: MVP에서 없음 (향후 캐싱 전략은 research.md 참조)

**삭제**: 해당 없음 (가상 엔티티는 페이지 렌더링 중에만 존재)

---

## 검증 규칙

### 태그 엔티티 (기존)

- `name`: 필수, 고유, 1-100자
- `slug`: 필수, 고유, 소문자 영숫자 + 하이픈, `~r/^[a-z0-9가-힣-]+$/` 패턴 일치

### 포스트 엔티티 (기존)

- `is_popular`: 불린, 기본값 false
- `published_at`: 필수, 유효한 UTC 날짜시간이어야 함

### CategoryStatistic (가상)

- `post_count`: 음이 아닌 정수 (COUNT 집계로 강제됨)
- `name`/`slug`: 태그 검증에서 상속됨 (이미 데이터베이스에서 검증됨)

---

## 인덱싱 전략

### 기존 인덱스 (검증됨)

- `posts.slug` (고유) - 포스트 조회용
- `posts.published_at` - 최근 포스트 정렬용
- `posts.is_popular` - 인기 포스트 필터링용
- `tags.slug` (고유) - 카테고리 조회용
- `posts_tags.(post_id, tag_id)` (복합) - 조인 성능용

### 기능에 필요한 인덱스

✅ **모든 인덱스가 이미 존재함** - 데이터베이스 변경 불필요

**쿼리 성능**:

- 집계 쿼리가 `posts_tags` 조인 테이블 인덱스 사용
- `tags.name`으로 정렬 시 테이블 스캔 사용 (200개 미만 태그에서 허용됨)
- MVP 성능 목표를 위한 추가 인덱스 불필요

---

## 데이터 제약사항

### 비즈니스 규칙

1. **태그 고유성**: 태그 이름은 고유해야 함 (데이터베이스 제약으로 강제됨)
2. **포스트-태그 연관**: 포스트는 0-N개의 태그를 가질 수 있고, 태그는 0-N개의 포스트를 가질 수 있음
3. **인기 포스트 제한**: 데이터베이스 제한 없음 (쿼리에서 애플리케이션 레벨 제한: 기본값 10)
4. **빈 카테고리**: 포스트가 0개인 태그는 `post_count = 0`으로 표시되어야 함 (FR-004)

### 처리되는 엣지 케이스

1. **태그 없음**: 쿼리가 빈 목록 반환 (드문 시나리오)
2. **포스트 없음**: 모든 태그가 `post_count = 0`으로 표시됨
3. **인기 포스트 없음**: 인기 섹션이 빈 상태 메시지 표시
4. **삭제된 포스트**: 포스트 삭제 시 `post_count` 자동 감소 (캐스케이드)
5. **삭제된 태그**: 통계에서 태그 제거됨 (`posts_tags`에서 캐스케이드 삭제)

---

## 성능 특성

### 쿼리 복잡성

- **집계 쿼리**: O(N) (N = 포스트-태그 연관 수)
- **정렬**: O(T log T) (T = 태그 수)
- **예상 규모**:
  - 50-100개 태그: <10ms 쿼리 시간
  - 1000개 포스트: <50ms 쿼리 시간
  - 100개 이상 카테고리: <100ms 쿼리 시간 (SC-003 예산 내)

### 메모리 사용량

- **CategoryStatistic**: 태그당 ~100바이트 (id + name + slug + count)
- **100개 태그**: ~10KB 메모리 (무시할 수 있음)
- **LiveView 프로세스**: ~200KB 총합 (표준 Phoenix LiveView)

---

## 스키마 마이그레이션 상태

**필요한 데이터베이스 마이그레이션**: ❌ 없음

**근거**:

- 필요한 모든 테이블과 컬럼이 이미 존재함
- 기능이 기존 `posts`, `tags`, `posts_tags` 테이블 사용
- 새로운 필드, 인덱스, 제약사항 불필요
- 가상 엔티티(CategoryStatistic)는 런타임에 계산됨

**검증**:

```bash
# 기존 스키마 확인
mix ecto.migrations  # 마이그레이션 히스토리 확인
sqlite3 priv/repo/elixir_blog.db ".schema posts_tags"  # 조인 테이블 확인
```

---

## 데이터 접근 패턴

### 읽기 작업 (CategoryStatsLive)

1. **포스트 수가 포함된 모든 태그 나열**:
   - 함수: `Blog.list_tags_with_post_counts(sort: :alphabetical)`
   - 빈도: 모든 페이지 로드마다 (캐싱 없음)
   - 예상 수: 50-100개 태그

2. **인기 포스트 나열**:
   - 함수: `Blog.list_popular_posts(limit: 10)`
   - 빈도: 모든 페이지 로드마다
   - 예상 수: 5-10개 포스트

3. **카테고리별 포스트 나열** (CategoryLive):
   - 함수: `Blog.list_posts_by_category(tag_slug, limit: 50)`
   - 빈도: 카테고리 상세 페이지 로드 시
   - 예상 수: 가변적 (카테고리당 1-100개 포스트)

### 쓰기 작업

- **없음** - 이 기능은 읽기 전용 (통계 표시)

### 트랜잭션 요구사항

- **없음** - 모든 작업이 일관된 스냅샷을 가진 격리된 읽기

---

## 향후 고려사항

### 잠재적 스키마 개선사항 (MVP 범위 외)

1. **태그 메타데이터**:
   - `description` (텍스트) - 카테고리 설명
   - `color` (문자열) - 시각적 색상 코딩
   - `icon` (문자열) - 아이콘 식별자

2. **조회 추적**:
   - `tags.view_count` (정수) - 카테고리 페이지 조회 추적
   - `tags.last_viewed_at` (타임스탬프) - 마지막 접근 시간

3. **구체화된 뷰** (성능이 문제가 되는 경우):
   - 미리 계산된 `tag_statistics` 테이블
   - 백그라운드 새로고침 작업
   - 캐시 무효화 전략 필요

### 캐싱 전략 (연기됨)

- **구현 시기**: 페이지 로드가 2초를 초과하는 경우 (SC-001)
- **접근법**: 5분 TTL이 있는 ETS 캐시
- **무효화**: 포스트 생성/업데이트/삭제 이벤트 시
- **참조**: 자세한 캐싱 설계는 research.md 섹션 5 참조

---

## 요약

### 사용된 엔티티

- ✅ **태그** (기존) - 카테고리의 소스 엔티티
- ✅ **포스트** (기존) - 통계를 위해 카운트됨, 인기 섹션에 표시됨
- ✅ **CategoryStatistic** (가상) - 집계된 런타임 데이터 구조

### 스키마 변경

- ❌ **불필요** - 기능이 기존 데이터베이스 스키마 사용

### 성능 영향

- ✅ **최소** - 단일 집계 쿼리 (<100ms)
- ✅ **인덱스 불필요** - 기존 인덱스로 충분
- ✅ **잠금 없음** - 읽기 전용 작업

### 데이터 무결성

- ✅ **유지됨** - 기존 외래 키 제약사항 사용
- ✅ **검증됨** - 태그/포스트 스키마 검증 상속
- ✅ **일관됨** - 트랜잭션 읽기로 스냅샷 일관성 보장
