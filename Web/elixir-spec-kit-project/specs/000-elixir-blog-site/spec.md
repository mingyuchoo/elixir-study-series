# 기능 명세서: Elixir 블로그 사이트

**기능 브랜치**: `001-korean-blog-site`
**생성일**: 2025-12-29
**상태**: 초안
**입력**: 사용자 설명: "# 블로그 사이트

Elixir로 된 블로그 사이트를 제작할거야. 홈페이지와 상세 페이지가 있어야 돼.

## 공통 구조

- 헤더 네비게이션
- Footer

## 홈페이지 구조

- Carosel Hero 섹션 (인기 블로그 글)
- 인기 블로그 Grid
- 카테고리별 블로그 Grid
- 이메일 구독하기 CTA

## 상세 페이지 구조

- 제목
- 메타데이터 (저자, 태그, 읽는데 걸리는 시간)
- 썸네일
- 내용
- ToC

## 블로그 필수 정보

- 저자
- 태그
- 썸네일 이밎
- 내용 (Markdown)
- 요약
- 읽는데 걸리는 시간

샘플 블로그 포스트는 50개 정도 제작해주고 블로그 글은 마크다운으로 관리할거야."

## 사용자 시나리오 및 테스트 *(필수)*

### 사용자 스토리 1 - 블로그 포스트 탐색 및 발견 (우선순위: P1)

방문자들이 블로그 홈페이지를 통해 매력적인 캐러셀과 그리드 레이아웃을 통해 인기 있고 카테고리별로 분류된 콘텐츠를 발견할 수 있습니다. 홈페이지는 블로그 콘텐츠를 발견하는 주요 진입점 역할을 합니다.

**이 우선순위인 이유**: 이는 콘텐츠 발견을 가능하게 하고 참여를 유도하는 핵심 사용자 대면 기능입니다. 이것 없이는 사용자가 어떤 블로그 콘텐츠에도 접근할 수 없습니다.

**독립적 테스트**: 홈페이지로 이동하여 모든 섹션이 올바르게 로드되는지 확인(캐러셀, 인기 포스트 그리드, 카테고리 그리드, 이메일 구독 폼)하여 완전히 테스트할 수 있으며, 사용자가 콘텐츠를 발견하고 접근할 수 있도록 하여 즉각적인 가치를 제공합니다.

**수락 시나리오**:

1. **주어진 조건** 방문자가 홈페이지에 도착했을 때, **행동** 페이지가 로드되면, **결과** 썸네일 이미지, 제목, 네비게이션 컨트롤이 있는 인기 블로그 포스트를 표시하는 캐러셀 히어로 섹션을 볼 수 있습니다
2. **주어진 조건** 방문자가 홈페이지에 있을 때, **행동** 아래로 스크롤하면, **결과** 썸네일, 제목, 저자명, 읽기 시간 추정치가 있는 인기 블로그 포스트 그리드를 볼 수 있습니다
3. **주어진 조건** 방문자가 홈페이지에 있을 때, **행동** 계속 스크롤하면, **결과** 별도의 그리드 섹션에서 카테고리별로 정리된 블로그 포스트를 볼 수 있습니다
4. **주어진 조건** 방문자가 홈페이지에 있을 때, **행동** 하단에 도달하면, **결과** 이메일 구독 CTA(행동 유도) 섹션을 볼 수 있습니다
5. **주어진 조건** 방문자가 홈페이지에 있을 때, **행동** 캐러셀과 상호작용하면, **결과** 이전/다음 컨트롤이나 인디케이터를 사용하여 추천 포스트 간을 탐색할 수 있습니다
6. **주어진 조건** 방문자가 블로그 포스트(캐러셀이나 그리드에서)를 클릭했을 때, **행동** 클릭이 등록되면, **결과** 해당 블로그 포스트 상세 페이지로 이동합니다

---

### 사용자 스토리 2 - 블로그 포스트 콘텐츠 읽기 (우선순위: P1)

독자들이 모든 메타데이터, 콘텐츠, 네비게이션 도구와 함께 완전한 블로그 포스트를 볼 수 있습니다. 이는 구조화되고 읽기 쉬운 형식으로 블로그 콘텐츠를 소비하는 핵심 가치를 제공합니다.

**이 우선순위인 이유**: 이는 탐색만큼 중요합니다 - 이는 주요 소비 경험입니다. 이것 없이는 사용자가 발견한 콘텐츠를 실제로 읽을 수 없습니다.

**독립적 테스트**: 블로그 포스트 상세 페이지로 이동하여 모든 요소가 올바르게 렌더링되는지 확인(제목, 메타데이터, 썸네일, 마크다운 콘텐츠, 목차)하여 완전히 테스트할 수 있으며, 완전한 읽기 경험을 제공합니다.

**수락 시나리오**:

1. **주어진 조건** 독자가 블로그 포스트 상세 페이지로 이동했을 때, **행동** 페이지가 로드되면, **결과** 상단에 포스트 제목이 눈에 띄게 표시됩니다
2. **주어진 조건** 독자가 블로그 포스트를 보고 있을 때, **행동** 제목 아래를 보면, **결과** 저자명, 태그, 예상 읽기 시간을 포함한 메타데이터를 볼 수 있습니다
3. **주어진 조건** 독자가 블로그 포스트를 보고 있을 때, **행동** 계속 읽으면, **결과** 포스트의 썸네일 이미지가 눈에 띄게 표시됩니다
4. **주어진 조건** 독자가 블로그 포스트를 보고 있을 때, **행동** 페이지를 스크롤하면, **결과** 적절한 형식(제목, 단락, 목록, 코드 블록 등)으로 마크다운에서 렌더링된 전체 블로그 콘텐츠를 볼 수 있습니다
5. **주어진 조건** 독자가 블로그 포스트를 보고 있을 때, **행동** 페이지가 로드되면, **결과** 포스트의 모든 주요 제목을 나열하는 목차(ToC)를 볼 수 있습니다
6. **주어진 조건** 독자가 목차 항목을 클릭했을 때, **행동** 클릭이 등록되면, **결과** 페이지가 콘텐츠의 해당 섹션으로 스크롤됩니다
7. **주어진 조건** 독자가 메타데이터의 태그를 클릭했을 때, **행동** 클릭이 등록되면, **결과** 같은 태그를 가진 다른 포스트들이 표시됩니다

---

### 사용자 스토리 3 - 사이트 구조 탐색 (우선순위: P2)

사용자들이 모든 페이지에서 사용할 수 있는 일관된 네비게이션 요소를 사용하여 블로그 사이트의 다른 섹션 간을 탐색할 수 있습니다.

**이 우선순위인 이유**: 네비게이션은 사용성에 필수적이지만 핵심 콘텐츠 보기가 작동한 후에 구현할 수 있습니다. 사용자는 여전히 직접 링크를 통해 콘텐츠에 접근할 수 있기 때문입니다.

**독립적 테스트**: 헤더 네비게이션과 푸터가 모든 페이지(홈페이지와 상세 페이지)에 작동하는 링크와 함께 나타나는지 확인하여 테스트할 수 있으며, 사용자가 브라우저의 뒤로/앞으로 버튼 없이 섹션 간을 이동할 수 있게 합니다.

**수락 시나리오**:

1. **주어진 조건** 사용자가 블로그 사이트의 어떤 페이지에 있을 때, **행동** 페이지 상단을 보면, **결과** 네비게이션 링크가 있는 헤더를 볼 수 있습니다
2. **주어진 조건** 사용자가 블로그 사이트의 어떤 페이지에 있을 때, **행동** 하단으로 스크롤하면, **결과** 추가 네비게이션과 정보가 있는 푸터를 볼 수 있습니다
3. **주어진 조건** 사용자가 헤더의 네비게이션 링크를 클릭했을 때, **행동** 클릭이 등록되면, **결과** 해당 섹션이나 페이지로 이동합니다
4. **주어진 조건** 사용자가 상세 페이지에 있을 때, **행동** 헤더의 사이트 로고나 홈 링크를 클릭하면, **결과** 홈페이지로 다시 이동합니다

---

### 사용자 스토리 4 - 블로그 업데이트 구독 (우선순위: P3)

방문자들이 이메일을 통해 블로그 업데이트를 구독하여 새로운 콘텐츠에 대한 정보를 받을 수 있습니다.

**이 우선순위인 이유**: 이는 가치 있는 참여 기능이지만 핵심 읽기 경험에는 중요하지 않습니다. 콘텐츠 소비 플로우가 완료된 후에 추가할 수 있습니다.

**독립적 테스트**: 홈페이지의 구독 폼을 통해 이메일 주소를 제출하고 제출이 올바르게 처리되는지 확인하여 테스트할 수 있으며, 사용자가 업데이트를 선택할 수 있게 합니다.

**수락 시나리오**:

1. **주어진 조건** 방문자가 홈페이지에 있을 때, **행동** 구독 CTA 폼에 이메일 주소를 입력하면, **결과** 이메일이 올바른 형식인지 검증됩니다
2. **주어진 조건** 방문자가 유효한 이메일을 입력했을 때, **행동** 구독 폼을 제출하면, **결과** 성공적인 구독을 나타내는 확인 메시지를 볼 수 있습니다
3. **주어진 조건** 방문자가 유효하지 않은 이메일을 입력했을 때, **행동** 구독 폼을 제출하면, **결과** 문제를 설명하는 오류 메시지를 볼 수 있습니다
4. **주어진 조건** 방문자가 이미 구독된 이메일을 제출했을 때, **행동** 폼이 처리되면, **결과** 이미 구독되어 있다는 메시지를 볼 수 있습니다

---

### 사용자 스토리 5 - 카테고리별 포스트 필터링 (우선순위: P3)

독자들이 특정 카테고리 내의 포스트를 탐색하여 관심사와 관련된 콘텐츠를 찾을 수 있습니다.

**이 우선순위인 이유**: 발견 가능성을 향상시키지만 홈페이지에서 이미 카테고리별 콘텐츠를 보여줍니다. 이는 전용 카테고리 탐색을 추가하는 것으로 가치 있지만 MVP에는 중요하지 않습니다.

**독립적 테스트**: 카테고리 라벨을 클릭하고 포스트가 해당 카테고리의 콘텐츠만 표시하도록 필터링되는지 확인하여 테스트할 수 있으며, 사용자가 주제별로 관련된 포스트를 찾는 데 도움이 됩니다.

**수락 시나리오**:

1. **주어진 조건** 사용자가 홈페이지에 있을 때, **행동** 카테고리 라벨이나 섹션 헤더를 클릭하면, **결과** 해당 카테고리의 포스트만 표시하는 필터링된 뷰를 볼 수 있습니다
2. **주어진 조건** 사용자가 카테고리 필터링된 페이지를 보고 있을 때, **행동** 페이지를 보면, **결과** 어떤 카테고리를 탐색하고 있는지 명확한 표시를 볼 수 있습니다
3. **주어진 조건** 사용자가 카테고리 필터링된 페이지를 보고 있을 때, **행동** 모든 포스트로 돌아가고 싶으면, **결과** 필터를 지우거나 홈페이지로 다시 이동할 수 있습니다

---

### 예외 상황

- 블로그 포스트에 썸네일 이미지가 지정되지 않았을 때 어떻게 될까요?
- 시스템이 매우 짧거나 매우 긴 읽기 시간을 가진 블로그 포스트를 어떻게 처리할까요? (예: 1분 vs 45분)
- 블로그 포스트에 태그가 할당되지 않았을 때 어떻게 될까요?
- 추천 포스트가 3개 미만일 때 캐러셀은 어떻게 동작할까요? 또는 1개만 있을 때는?
- 카테고리에 포스트가 없을 때 어떻게 될까요?
- 제목이 없거나 하나만 있는 포스트에서 목차는 어떻게 동작할까요?
- 마크다운 콘텐츠에 잘못된 구문이 포함되어 있을 때 어떻게 될까요?
- 이메일 구독 폼이 공백이나 특이하지만 유효한 이메일 형식을 어떻게 처리할까요?
- 블로그 포스트 콘텐츠가 매우 길 때(예: 10,000단어 이상) 어떻게 될까요?
- 사이트가 레이아웃을 깨뜨릴 수 있는 매우 긴 제목을 가진 포스트를 어떻게 처리할까요?

## 요구사항 *(필수)*

### 기능 요구사항

- **FR-001**: 시스템은 인기 블로그 포스트를 특징으로 하는 캐러셀 히어로 섹션이 있는 홈페이지를 표시해야 합니다
- **FR-002**: 시스템은 캐러셀 아래 홈페이지에 인기 블로그 포스트 그리드를 표시해야 합니다
- **FR-003**: 시스템은 홈페이지에서 별도의 그리드 섹션으로 카테고리별 블로그 포스트를 정리하고 표시해야 합니다
- **FR-004**: 시스템은 사용자가 업데이트를 구독할 수 있도록 홈페이지에 이메일 구독 폼을 제공해야 합니다
- **FR-005**: 시스템은 모든 페이지에 헤더 네비게이션 컴포넌트를 표시해야 합니다
- **FR-006**: 시스템은 모든 페이지에 푸터 컴포넌트를 표시해야 합니다
- **FR-007**: 시스템은 제목, 메타데이터, 썸네일, 콘텐츠가 있는 개별 블로그 포스트 상세 페이지를 렌더링해야 합니다
- **FR-008**: 시스템은 상세 페이지에서 저자명, 태그, 예상 읽기 시간을 포함한 포스트 메타데이터를 표시해야 합니다
- **FR-009**: 시스템은 마크다운 형식에서 적절한 형식으로 블로그 포스트 콘텐츠를 렌더링해야 합니다
- **FR-010**: 시스템은 블로그 포스트의 제목을 기반으로 목차(ToC)를 생성하고 표시해야 합니다
- **FR-011**: 시스템은 사용자가 목차 항목을 클릭하여 해당 콘텐츠 섹션으로 이동할 수 있도록 해야 합니다
- **FR-012**: 시스템은 관련 메타데이터와 함께 블로그 포스트를 마크다운 파일로 저장해야 합니다
- **FR-013**: 시스템은 각 블로그 포스트의 예상 읽기 시간을 계산하고 표시해야 합니다
- **FR-014**: 시스템은 사용자가 링크를 통해 홈페이지와 상세 페이지 간을 탐색할 수 있도록 해야 합니다
- **FR-015**: 시스템은 사용자가 태그를 클릭하여 같은 태그를 가진 다른 포스트를 볼 수 있도록 해야 합니다
- **FR-016**: 시스템은 약 50개의 샘플 블로그 포스트로 초기 콘텐츠를 제공해야 합니다
- **FR-017**: 시스템은 모든 콘텐츠와 사용자 인터페이스 텍스트를 Elixir로 표시해야 합니다
- **FR-018**: 시스템은 구독 폼을 통해 제출된 이메일 주소를 검증해야 합니다
- **FR-019**: 시스템은 폼 제출에 대한 시각적 피드백(성공 또는 오류 상태)을 제공해야 합니다
- **FR-020**: 캐러셀 컨트롤은 사용자가 추천 포스트 간을 수동으로 탐색할 수 있도록 해야 합니다

### 주요 엔티티

- **블로그 포스트**: 제목, 저자명, 태그 목록, 썸네일 이미지 참조, 마크다운 콘텐츠, 요약 텍스트, 계산된 읽기 시간 추정치를 포함한 속성을 가진 개별 블로그 기사를 나타냅니다. 태그 연관을 통해 카테고리와 관련됩니다.

- **저자**: 이름 속성을 가진 콘텐츠 작성자를 나타냅니다. 여러 블로그 포스트와 연관됩니다. MVP에서는 단순한 문자열 참조로 가정합니다.

- **태그/카테고리**: 블로그 포스트의 분류 또는 주제 라벨을 나타냅니다. 콘텐츠를 정리하고 필터링하는 데 사용됩니다. 블로그 포스트는 여러 태그를 가질 수 있습니다.

- **이메일 구독**: 이메일 주소 속성을 가진 사용자의 이메일 구독 요청을 나타냅니다. 홈페이지 CTA 폼을 통해 수집됩니다.

## 성공 기준 *(필수)*

### 측정 가능한 결과

- **SC-001**: 방문자가 홈페이지에서 3클릭 이내에 블로그 포스트를 발견하고 이동할 수 있습니다
- **SC-002**: 독자가 목차를 사용하여 5초 이내에 블로그 포스트 내의 특정 콘텐츠 섹션을 찾을 수 있습니다
- **SC-003**: 홈페이지의 캐러셀이 부드러운 전환과 함께 추천 포스트를 표시하고 탐색을 허용합니다
- **SC-004**: 블로그 콘텐츠가 마크다운 형식에서 형식(제목, 목록, 코드 블록, 강조)을 100% 보존하여 렌더링됩니다
- **SC-005**: 사용자가 유효한 이메일 주소로 이메일 구독을 성공적으로 제출하면 2초 이내에 확인을 받습니다
- **SC-006**: 모든 50개의 샘플 블로그 포스트가 완전한 메타데이터와 함께 접근 가능하고 적절히 형식화됩니다
- **SC-007**: 카테고리 기반 탐색을 통해 사용자가 2초 이내에 필터링된 뷰가 로드되는 포스트를 필터링할 수 있습니다
- **SC-008**: 읽기 시간 추정치가 90%의 포스트에서 실제 읽기 시간의 ±1분 정확도로 표시됩니다
- **SC-009**: 네비게이션 요소(헤더와 푸터)가 모든 페이지에서 일관되게 사용 가능합니다
- **SC-010**: 사용자가 사이트의 어떤 두 페이지 간에도 2클릭 이내에 탐색할 수 있습니다

### 가정사항

- 이메일 구독은 향후 사용을 위해 수집되고 저장됩니다; 실제 이메일 전송 구현은 초기 MVP에 필요하지 않습니다
- "인기" 블로그 포스트는 동적 분석이 아닌 콘텐츠 파일의 미리 정의된 플래그나 순서에 의해 결정됩니다
- 캐러셀은 기본 5초 간격으로 자동 진행되며, 수동 컨트롤을 사용할 수 있습니다
- 읽기 시간 계산은 분당 약 200-250단어의 업계 표준 비율을 사용합니다
- 카테고리는 별도의 카테고리 분류법이 아닌 태그로 정의됩니다; 포스트는 여러 카테고리에 속할 수 있습니다
- 썸네일 이미지는 샘플 콘텐츠의 일부로 제공되며 포스트 메타데이터에서 파일 경로/URL로 참조됩니다
- 사이트는 콘텐츠 전달과 SEO에 최적화된 정적 또는 서버 렌더링 사이트가 됩니다
- 모든 50개의 샘플 블로그 포스트는 저자, 태그, 썸네일, 요약, 읽기 시간을 포함한 완전한 메타데이터를 가집니다
- 마크다운 콘텐츠는 표준 마크다운 구문(CommonMark 또는 GitHub Flavored Markdown)을 지원합니다
- 목차는 마크다운 콘텐츠의 H2와 H3 제목에서 생성됩니다
- 네비게이션 구조는 홈페이지와 개별 포스트 페이지가 있는 단순한 사이트 아키텍처를 가정합니다; 카테고리 필터링은 필터링된 홈페이지 뷰로 구현될 수 있습니다
- Elixir 콘텐츠는 적절한 문자 렌더링을 보장하기 위해 UTF-8 인코딩을 사용합니다
