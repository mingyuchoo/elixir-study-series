# 연구 및 기술적 결정: Elixir 블로그 사이트

**브랜치**: `001-korean-blog-site` | **날짜**: 2025-12-29
**목적**: 명확화 필요 항목 해결 및 기술 선택 문서화

## Phase 0: 연구 결과

### 1. 성능 목표 - 동시 사용자 및 페이지 로드 시간

**결정**: 100명의 동시 사용자를 목표로 하며 초기 페이지 로드 <500ms, LiveView 업데이트 <200ms

**근거**:

- Phoenix LiveView는 최소한의 페이로드 크기로 실시간 업데이트에 최적화되어 있음
- 50개 포스트가 있는 콘텐츠 중심 블로그의 경우 100명의 동시 사용자가 합리적인 초기 목표
- 성공 기준에서 이미 필터링된 뷰 <2초, 목차 네비게이션 <5초를 명시함
- 초기 페이지 로드 <500ms는 현대 웹 성능 표준에 부합
- LiveView 상태 업데이트는 적절한 최적화로 <200ms 응답 시간 달성 가능

**고려된 대안**:

- **1000+ 동시 사용자**: 50개 포스트가 있는 초기 배포에는 조기 최적화로 거부
- **정적 사이트 생성(SSG)**: JavaScript 복잡성 없이 캐러셀, 필터링, 이메일 구독에 더 나은 상호작용성을 제공하는 LiveView 때문에 거부
- **더 높은 페이지 로드 목표(1-2초)**: 경쟁력 있는 사용자 경험을 보장하기 위해 거부

**구현 참고사항**:

- 자주 쿼리되는 필드(tags, published_at, is_popular)에 적절한 인덱싱을 사용한 SQLite 사용
- Phoenix LiveView 모범 사례 구현: 최소한의 assigns, 선택적 재렌더링
- 자주 접근되는 포스트를 위해 ETS를 사용하여 파싱된 마크다운 콘텐츠를 메모리에 캐시
- 필요한 경우 실시간 캐러셀 업데이트를 위해 Phoenix.PubSub 사용
- 성능 메트릭을 위해 Telemetry로 모니터링

---

### 2. 마크다운 파서 선택

**결정**: Makeup을 통한 구문 강조와 함께 Earmark를 마크다운 파싱에 사용

**근거**:

- Earmark는 Elixir 생태계에서 사실상의 표준 마크다운 파서
- GitHub Flavored Markdown 확장과 함께 CommonMark 사양 지원
- 순수 Elixir 구현 (외부 의존성 없음)
- HTML 생성을 위해 Phoenix와 잘 통합됨
- Makeup은 코드 블록에 구문 강조 제공
- 두 라이브러리 모두 활발히 유지보수되고 프로덕션 준비됨

**고려된 대안**:

- **MDEx (markdown-it 래퍼)**: Elixir 전용 스택과 모순되는 Node.js 의존성으로 인해 거부
- **Cmark (C 바인딩)**: 네이티브 컴파일 복잡성을 피하기 위해 거부
- **커스텀 파서**: 불필요한 복잡성으로 거부

**구현 참고사항**:

- GitHub Flavored Markdown 옵션으로 Earmark 설정
- XSS 공격을 방지하기 위해 HTML 출력 살균
- 코드 블록의 구문 강조를 위해 Makeup.Lexers 사용
- 포스트 메타데이터를 위해 YamlElixir를 사용하여 마크다운 프론트매터를 별도로 파싱

---

### 3. 캐러셀을 위한 LiveView 컴포넌트 아키텍처

**결정**: 부드러운 전환을 위한 JavaScript 훅과 함께 상태 저장 LiveView 컴포넌트로 캐러셀 구현

**근거**:

- Phoenix LiveView 컴포넌트는 격리된 상태 관리 제공
- JavaScript 훅은 전체 페이지 재렌더링 없이 CSS 전환을 위한 Alpine.js 통합 허용
- LiveView가 네비게이션 상태(현재 슬라이드 인덱스)를 서버 측에서 처리
- Phoenix 프로세스(send_after)를 통해 관리되는 자동 진행 타이머
- 60fps 애니메이션을 위해 클라이언트 측에서 처리되는 CSS를 통한 부드러운 전환

**고려된 대안**:

- **순수 JavaScript 캐러셀**: LiveView의 서버 주도 모델을 깨뜨리기 때문에 거부
- **훅 없는 LiveView 전용**: 전환에서 잠재적인 끊김(네트워크 지연) 때문에 거부
- **서드파티 JS 라이브러리 (Swiper.js)**: JavaScript 의존성을 최소화하기 위해 거부

**구현 참고사항**:

- 캐러셀에 Phoenix.LiveView.Component 사용
- 컴포넌트 상태에서 현재 슬라이드 인덱스 관리
- CSS 기반 슬라이드 애니메이션을 위해 Alpine.js x-transition 사용
- JavaScript 훅을 사용하여 호버 시 일시정지 구현
- 5초마다 자동 진행 (설정 가능)

---

### 4. Elixir 언어 (i18n) 구현

**결정**: Elixir 로케일(ko)을 주 언어로 하는 Phoenix Gettext 사용

**근거**:

- Gettext는 Phoenix의 내장 국제화 프레임워크
- Elixir UTF-8 인코딩을 기본적으로 지원
- 더 나은 성능을 위한 컴파일 타임 번역
- 필요한 경우 나중에 추가 언어를 쉽게 추가 가능
- Phoenix 애플리케이션의 표준 접근법

**고려된 대안**:

- **하드코딩된 Elixir 문자열**: 향후 i18n을 위한 유연성을 유지하기 위해 거부
- **런타임 번역 서비스**: 단일 언어에는 불필요한 복잡성으로 거부

**구현 참고사항**:

- config에서 기본 로케일을 "ko"로 설정
- 모든 UI 문자열을 `priv/gettext/ko/LC_MESSAGES/default.po`에 저장
- 템플릿과 LiveView에서 `gettext`와 `dgettext` 매크로 사용
- 데이터베이스가 UTF-8 인코딩으로 Elixir 텍스트를 저장하도록 보장
- Ecto 스키마 필드를 `:string` 타입으로 설정 (기본적으로 UTF-8)

---

### 5. 블로그 포스트 메타데이터 저장 전략

**결정**: 하이브리드 접근법 - SQLite의 메타데이터, 프론트매터가 있는 마크다운 파일의 콘텐츠

**근거**:

- SQLite는 태그, 카테고리, 인기도별 필터링을 위한 효율적인 쿼리 제공
- 마크다운 파일은 콘텐츠를 사람이 읽기 쉽고 버전 관리 가능하게 유지
- 마크다운 파일의 프론트매터(YAML)는 메타데이터의 단일 진실 소스 제공
- 시딩 프로세스가 프론트매터를 파싱하고 데이터베이스를 채움
- 각 요청마다 50개의 마크다운 파일을 모두 파싱하지 않고도 빠른 쿼리 가능

**고려된 대안**:

- **데이터베이스 전용**: 데이터베이스에서 콘텐츠 편집이 사용자 친화적이지 않아 거부
- **파일 전용**: 느린 필터링과 쿼리 성능으로 인해 거부
- **별도 JSON의 메타데이터가 있는 마크다운**: 관련 데이터를 분할하므로 거부

**구현 참고사항**:

- 마크다운 파일 명명: `YYYY-MM-DD-slug.md`
- 프론트매터 형식 (YAML):

  ```yaml
  ---
  title: "블로그 포스트 제목"
  author: "저자명"
  tags: ["tag1", "tag2", "tag3"]
  thumbnail: "/images/thumbnails/post-slug.jpg"
  summary: "포스트의 간략한 요약"
  published_at: 2024-01-01T00:00:00Z
  is_popular: true
  ---
  ```

- 데이터베이스 스키마 포함: id, slug, title, author, summary, thumbnail, published_at, is_popular, reading_time, inserted_at, updated_at
- 다대다 관계로 별도 테이블에 저장된 태그
- 시드 스크립트가 프론트매터를 파싱하고 데이터베이스와 동기화

---

### 6. 읽기 시간 계산

**결정**: 단어 수 기반으로 시딩 중 계산 (평균 분당 250단어)

**근거**:

- 업계 표준 읽기 속도: 분당 200-250단어
- 시딩 중 한 번 계산하여 데이터베이스에 저장
- Elixir 텍스트 단어 계산: 한글 음절 블록과 공백 계산
- 각 페이지 로드마다 실시간 계산보다 정확함

**고려된 대안**:

- **실시간 계산**: 성능 오버헤드로 인해 거부
- **수동 지정**: 오류가 발생하기 쉽고 확장 가능하지 않아 거부

**구현 참고사항**:

- Elixir 문자와 단어를 계산하기 위해 정규식 사용
- 공식: `ceil(word_count / 250)` 분
- 데이터베이스에 정수(분)로 저장
- 포스트 콘텐츠가 변경될 때 업데이트

---

### 7. 이메일 구독 저장 및 검증

**결정**: 고유 이메일 제약조건으로 SQLite에 구독 저장, MVP에서는 이메일 전송 없음

**근거**:

- 기능 명세서에 "이메일 구독은 향후 사용을 위해 수집되고 저장됩니다"라고 명시
- 초기 MVP에서는 이메일 전송이 필요하지 않음
- 고유 제약조건이 중복 구독 방지
- 클라이언트(LiveView)와 서버(Ecto changeset) 모두에서 이메일 검증

**고려된 대안**:

- **서드파티 서비스 통합 (Mailchimp, SendGrid)**: MVP 범위를 벗어나므로 거부
- **지속성 없음**: 기능이 구독 저장을 요구하므로 거부

**구현 참고사항**:

- 데이터베이스 스키마: id, email (고유), subscribed_at, inserted_at
- Ecto changeset 검증: 형식 확인, 고유 제약조건
- 실시간 피드백이 있는 LiveView 폼 검증
- Gettext를 통한 Elixir 성공/오류 메시지

---

### 8. Docker 설정

**결정**: Alpine Linux 기반의 다단계 Dockerfile, 개발용 docker-compose

**근거**:

- 다단계 빌드가 최종 이미지 크기 감소
- Alpine Linux가 공격 표면 최소화
- docker-compose가 로컬 개발 설정 단순화
- Elixir 릴리스가 프로덕션 준비 배포 제공

**고려된 대안**:

- **Debian 기반 이미지**: 더 큰 크기로 인해 거부
- **Docker 없음**: 명시된 요구사항으로 거부

**구현 참고사항**:

- 빌드 단계: Mix 의존성이 있는 Elixir 1.19
- 런타임 단계: Elixir 런타임만 있는 Alpine
- SQLite 데이터베이스 지속성을 위한 볼륨 마운트
- Phoenix 서버용 포트 4000 노출
- 설정을 위한 환경 변수

---

### 9. Playwright MCP를 사용한 테스팅 전략

**결정**: 백엔드/LiveView 테스트용 ExUnit, 각 기능 후 브라우저 기반 UI 테스팅용 Playwright MCP

**근거**:

- ExUnit은 Elixir의 내장 테스팅 프레임워크로 단위 및 통합 테스트에 이상적
- Phoenix.LiveViewTest를 통한 LiveView 테스팅 지원
- Playwright MCP는 시각적 회귀 및 엔드투엔드 테스팅을 위한 브라우저 자동화 제공
- 사용자 요구사항에 따라: "작업이 끝날 때 마다 브라우저를 실행 하여 에러 해결"

**고려된 대안**:

- **Wallaby**: 명시된 Playwright MCP 대신 거부
- **ExUnit만**: 브라우저 테스팅이 필요하므로 거부

**구현 참고사항**:

- 도메인 로직용 ExUnit 테스트 (Post, Tag, Subscription 스키마)
- LiveView 컴포넌트 동작용 LiveViewTest
- Playwright 테스트 대상:
  - 캐러셀 상호작용
  - 카테고리 필터링
  - 이메일 구독 폼
  - 목차 네비게이션
  - Elixir 텍스트 렌더링
- 각 기능 구현 후 Playwright 테스트 실행
- Elixir 로케일을 사용하도록 Playwright 설정

---

## 기술 스택 요약

| 컴포넌트 | 기술 | 버전 |
| --------- | --------- | ------- |
| 언어 | Elixir | 1.19 |
| 웹 프레임워크 | Phoenix | 1.8.3 |
| 실시간 UI | Phoenix LiveView | 최신 (Phoenix 1.8.3에 번들됨) |
| 데이터베이스 | SQLite | 3.x |
| 마크다운 파서 | Earmark | ~1.4 |
| 구문 강조 | Makeup | ~1.1 |
| 메타데이터 파서 | YamlElixir | ~2.9 |
| i18n | Phoenix Gettext | 내장 |
| 프론트엔드 CSS | Tailwind CSS | 3.x |
| 프론트엔드 JS | Alpine.js | 3.x (캐러셀용 최소) |
| 테스팅 - 백엔드 | ExUnit | 내장 |
| 테스팅 - 브라우저 | Playwright MCP | 최신 |
| 컨테이너화 | Docker | 최신 |
| 오케스트레이션 | Docker Compose | 최신 |

---

## 위험 평가

### 낮은 위험

- ✅ Phoenix LiveView 성숙도와 안정성
- ✅ 소규모 블로그용 SQLite (50개 포스트)
- ✅ Earmark를 사용한 마크다운 파싱
- ✅ Elixir/Phoenix에서 Elixir 지원

### 중간 위험

- ⚠️ **캐러셀 성능**: 완화 - 클라이언트 측 전환을 위해 Alpine.js 사용
- ⚠️ **SQLite 동시성**: 완화 - 읽기 중심 워크로드가 SQLite에 적합
- ⚠️ **마크다운 파싱 성능**: 완화 - ETS에서 파싱된 콘텐츠 캐시

### 완화됨

- 🔧 Elixir 텍스트의 읽기 시간 정확도 - 음절 기반 계산 사용
- 🔧 복잡한 UI를 위한 LiveView 상태 관리 - 컴포넌트 기반 아키텍처 사용

---

## 미해결 질문 (차단되지 않음)

1. **썸네일 이미지 생성**: 썸네일이 제공되는가, 아니면 자동 생성을 구현해야 하는가?
   - **가정**: 썸네일은 샘플 콘텐츠의 일부로 제공됨

2. **태그 분류법**: 미리 정의된 태그/카테고리 목록이 있는가?
   - **가정**: 태그는 자유 형식이며 포스트 프론트매터에서 추출됨

3. **SEO 요구사항**: 메타 태그, 사이트맵 등을 구현해야 하는가?
   - **가정**: MVP에는 기본 SEO (제목, 메타 설명)로 충분

---

## 다음 단계

Phase 0 연구 완료. Phase 1로 진행:

1. 엔티티 스키마가 있는 data-model.md 생성
2. API 계약 정의 (LiveView 액션, 컴포넌트 인터페이스)
3. 개발 설정을 위한 quickstart.md 생성
4. 기술 스택으로 에이전트 컨텍스트 업데이트
